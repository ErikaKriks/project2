#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <vector>
#include <stdio.h>
#include <sstream>
#include <random> // for random number generation
#include <ctime>  // for seeding the random number generator
#include <cstdlib>
#include "functions.h"
#include <chrono> // For measuring time
#include <list> 



using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::list;
using std::printf;
using std::sort;
using std::ifstream;
using std::cerr;
using std::invalid_argument;
using std::runtime_error;
using std::to_string;
using std::default_random_engine;
using std::uniform_int_distribution;
using std::ofstream;
using std::left;
using std::setw;
using std::chrono::high_resolution_clock;
using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::seconds;
using std::stable_partition;



int main() {

    int choice;
    int choice2;
    int choice3;
    choice = usersChoice();
    cout << choice << endl;


    if (choice == 0) {
        // Students information will be written manually.
        
        choice2 =  usersChoiceAvgMed();
        
        int k;
        cout << "Number of students:" << endl;
        cin >> k;

        vector<Student> students;

        for (int i = 0; i < k; i++)
        {
            Student student;
            getInput(student);

            // Calculate Final Mark based on Average
            if (choice2 == 0) {
                student.finalMark = calculateFinalMarkAvg(student);
            }
            else {
                student.finalMark = calculateFinalMarkMed(student);
            }
            
            students.push_back(student);

        }

        printStudentTable(students);

        return 0;
    }


    else if (choice == 1) {
        // Students information will be autogenerated.
        int choice2;
        choice2 =  usersChoiceAvgMed();

        int k;
        cout << "Number of students:" << endl;
        cin >> k;

        vector<Student> students;
        default_random_engine generator(time(0)); // Seed the random number generator

        for (int i = 0; i < k; i++)
        {
            Student student;
            getInputAuto(student);

            // Calculate Final Mark based on Average
            if (choice2 == 0) {
                student.finalMark = calculateFinalMarkAvg(student);
            }
            else {
                student.finalMark = calculateFinalMarkMed(student);
            }

            students.push_back(student);
        }

        printStudentTable(students);

        return 0;
    }

    else if (choice == 2) {
        // Students information will be read from files and sorted out.
        vector<Student> students;
        string filename = "kursiokai.txt";

        auto start = std::chrono::high_resolution_clock::now(); // Start measuring time

        // Read student data from the file
        readStudentsFromFileVector(filename, students);

        auto end = std::chrono::high_resolution_clock::now(); // Stop measuring time
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        // Calculate Final Mark based on Average and Median of marks
        for (size_t i = 0; i < students.size(); ++i)
        {
            Student &student = students[i];

            // Calculate Final Mark based on Average
            student.finalMarkAvg = calculateFinalMarkAvg(student);

            // Calculate Final Mark based on Median
            student.finalMarkMed = calculateFinalMarkMed(student);
        }

        // Sort the students vector
        sort(students.begin(), students.end(), compareStudents);

        // Displaying a table of results
        printStudentTableAvgMed(students);

        // For testing purposes
        cout << "Total number of lines read: " << students.size() + 1 << " (including header)" << endl;
        cout << "Time taken to read the file: " << duration.count() << " microseconds" << endl;

        return 0;
    }

    else if (choice == 3)
    {
        choice2 = usersChoiceVectorList();
        vector<int> numStudentsList = {1000, 10000, 100000, 1000000, 10000000};
        // vector<int> numStudentsList = {10, 100}; // For testing purposes
        
        // Defining time variables used in both strategies
        std::chrono::duration<double> categorizationTime;
        std::chrono::duration<double> savingCategorizedTime;

        if (choice2 == 1)
        {
            // List structure will be used.
            choice3 = usersChoiceStrategy();

            for (int numStudents : numStudentsList)
            {
                // Data generation and saving
                auto startGeneration = std::chrono::high_resolution_clock::now();
                list<Student> students;
                for (int i = 1; i <= numStudents; ++i)
                {
                    students.push_back(generateRandomStudent(i, 15)); // 15 random individual marks
                }
                string filename = "students" + to_string(numStudents) + ".txt";
                saveStudentDataToFileList(filename, students);
                auto endGeneration = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double> generationTime = endGeneration - startGeneration;

                // Reading data
                auto startReading = std::chrono::high_resolution_clock::now();
                list<Student> readStudents;
                readStudentsFromFileList(filename, readStudents);
                auto endReading = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double> readingTime = endReading - startReading;


                if (choice3 == 1)
                {
                    // Strategy 1 - sorting students into two lists
                    // Categorization
                    auto startCategorization = std::chrono::high_resolution_clock::now();
                    list<Student> failStudents;
                    list<Student> passStudents;

                    for (const Student &student : readStudents)
                    {
                        float finalMark = calculateFinalMarkAvg(student); // You can use either Avg or Med function
                        if (finalMark < 5.0)
                        {
                            failStudents.push_back(student);
                        }
                        else
                        {
                            passStudents.push_back(student);
                        }
                    }

                    // Sort the failStudents and passStudents lists
                    failStudents.sort(compareStudents);
                    passStudents.sort(compareStudents);
                    auto endCategorization = std::chrono::high_resolution_clock::now();
                    categorizationTime = endCategorization - startCategorization;

                    // Saving categorized data
                    auto startSavingCategorized = std::chrono::high_resolution_clock::now();
                    string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
                    string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

                    saveStudentDataToFileList(filenameFail, failStudents);
                    saveStudentDataToFileList(filenamePass, passStudents);
                    auto endSavingCategorized = std::chrono::high_resolution_clock::now();
                    savingCategorizedTime = endSavingCategorized - startSavingCategorized;
                }
                else if (choice3 == 2)
                {
                    // Strategy 2 - using only one additional list
                    // Categorization
                    auto startCategorization = std::chrono::high_resolution_clock::now();
                    list<Student> failStudents;

                    for (auto it = readStudents.begin(); it != readStudents.end();)
                    {
                        Student &student = *it;
                        student.finalMark = calculateFinalMarkAvg(student);

                        if (student.finalMark < 5.0)
                        {
                            failStudents.push_back(student);
                            it = readStudents.erase(it); // Erase and get the iterator to the next element
                        }
                        else
                        {
                            ++it; // Move to the next element
                        }
                    }

                    // Sort the failStudents and passStudents lists
                    failStudents.sort(compareStudents);
                    readStudents.sort(compareStudents);
                    auto endCategorization = std::chrono::high_resolution_clock::now();
                    categorizationTime = endCategorization - startCategorization;

                    // Saving categorized data
                    auto startSavingCategorized = std::chrono::high_resolution_clock::now();
                    string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
                    string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

                    saveStudentDataToFileList(filenameFail, failStudents);
                    saveStudentDataToFileList(filenamePass, readStudents);
                    auto endSavingCategorized = std::chrono::high_resolution_clock::now();
                    savingCategorizedTime = endSavingCategorized - startSavingCategorized;
                }
                else if (choice3 == 3)
                {
                    cout << "This option is applicable only for VECTOR container type." << endl;
                    return 0;
                }

                // Output
                cout << "Execution times for " << numStudents << " students:" << endl;
                cout << "Memory address of the data structure: " << &students << endl;
                cout << "Data generation and saving: " << generationTime.count() << " seconds" << endl;
                cout << "Reading: " << readingTime.count() << " seconds" << endl;
                cout << "Categorization: " << categorizationTime.count() << " seconds" << endl;
                cout << "Saving categorized data: " << savingCategorizedTime.count() << " seconds" << endl;
                cout << "------------------------" << endl;
            }

            return 0;
        }
        else if (choice2 == 0) {
            // Vector structure will be used.
            choice3 = usersChoiceStrategy();

        for (int numStudents : numStudentsList) {
            // Data generation and saving
            auto startGeneration = std::chrono::high_resolution_clock::now();
            vector<Student> students;
            for (int i = 1; i <= numStudents; ++i) {
                students.push_back(generateRandomStudent(i, 15)); // 15 random individual marks
            }
            string filename = "students" + to_string(numStudents) + ".txt";
            saveStudentDataToFileVector(filename, students);
            auto endGeneration = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> generationTime = endGeneration - startGeneration;

            // Reading data
            auto startReading = std::chrono::high_resolution_clock::now();
            vector<Student> readStudents;
            readStudentsFromFileVector(filename, readStudents);
            auto endReading = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> readingTime = endReading - startReading;
            
            if (choice3 == 1) {
                // Categorization
                auto startCategorization = std::chrono::high_resolution_clock::now();
                vector<Student> failStudents;
                vector<Student> passStudents;

                for (const Student& student : readStudents) {
                    float finalMark = calculateFinalMarkAvg(student); // You can use either Avg or Med function
                    if (finalMark < 5.0) {
                        failStudents.push_back(student);
                    } else {
                        passStudents.push_back(student);
                    }
                }

                // Sort the failStudents and passStudents vectors
                sort(failStudents.begin(), failStudents.end(), compareStudents);
                sort(passStudents.begin(), passStudents.end(), compareStudents);
                auto endCategorization = std::chrono::high_resolution_clock::now();
                categorizationTime = endCategorization - startCategorization;

                // Saving categorized data
                auto startSavingCategorized = std::chrono::high_resolution_clock::now();
                string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
                string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

                saveStudentDataToFileVector(filenameFail, failStudents);
                saveStudentDataToFileVector(filenamePass, passStudents);
                auto endSavingCategorized = std::chrono::high_resolution_clock::now();
                savingCategorizedTime = endSavingCategorized - startSavingCategorized;
            }

            else if (choice3 == 2) {
                // Categorization
                auto startCategorization = std::chrono::high_resolution_clock::now();
                vector<Student> failStudents;

                for (auto it = readStudents.begin(); it != readStudents.end();)
                {
                    Student &student = *it;
                    student.finalMark = calculateFinalMarkAvg(student);

                    if (student.finalMark < 5.0)
                    {
                        failStudents.push_back(student);
                        it = readStudents.erase(it); 
                    }
                    else
                    {
                        ++it;
                    }
                }

                // Sort the Students vector
                sort(failStudents.begin(), failStudents.end(), compareStudents);
                sort(readStudents.begin(), readStudents.end(), compareStudents);
                auto endCategorization = std::chrono::high_resolution_clock::now();
                categorizationTime = endCategorization - startCategorization;

                // Saving categorized data
                auto startSavingCategorized = std::chrono::high_resolution_clock::now();
                string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
                string filenamePass = "students" + to_string(numStudents) + "_pass.txt";


                // Save failStudents to the file
                saveStudentDataToFileVector(filenameFail, failStudents);
                saveStudentDataToFileVector(filenamePass, readStudents);

                auto endSavingCategorized = std::chrono::high_resolution_clock::now();
                savingCategorizedTime = endSavingCategorized - startSavingCategorized;
            }

            else if (choice3 == 3) {
                // Strategy 3
                // Categorization using std::stable_partition
                auto startCategorization = std::chrono::high_resolution_clock::now();
                vector<Student> failStudents;

                // Stable partition based on the failing condition
                auto partitionPoint = stable_partition(readStudents.begin(), readStudents.end(),
                                                    [](const Student& student) {
                                                        return calculateFinalMarkAvg(student) < 5.0;
                                                    });

                // Move failing students to the failStudents vector
                failStudents.assign(readStudents.begin(), partitionPoint);

                // Erase failing students from the readStudents vector
                readStudents.erase(readStudents.begin(), partitionPoint);

                auto endCategorization = std::chrono::high_resolution_clock::now();
                categorizationTime = endCategorization - startCategorization;

                // Saving categorized data
                auto startSavingCategorized = std::chrono::high_resolution_clock::now();
                string filenameFail = "students" + to_string(numStudents) + "_fail.txt";
                string filenamePass = "students" + to_string(numStudents) + "_pass.txt";

                saveStudentDataToFileVector(filenameFail, failStudents);
                saveStudentDataToFileVector(filenamePass, readStudents);
                auto endSavingCategorized = std::chrono::high_resolution_clock::now();
                savingCategorizedTime = endSavingCategorized - startSavingCategorized;
            }

            else {
                cout << "Invalid choice. Exiting..." << endl;
                return 1;
            }

            // Output
            cout << "Execution times for " << numStudents << " students:" << endl;
            cout << "Memory address of the data structure: " << &students << endl;
            cout << "Data generation and saving: " << generationTime.count() << " seconds" << endl;
            cout << "Reading: " << readingTime.count() << " seconds" << endl;
            cout << "Categorization: " << categorizationTime.count() << " seconds" << endl;
            cout << "Saving categorized data: " << savingCategorizedTime.count() << " seconds" << endl;
            cout << "------------------------" << endl;
        }
            return 0;
        }
        else
        {
            cout << "Invalid choice. Exiting..." << endl;
            return 1; 
        }        
    }
}

